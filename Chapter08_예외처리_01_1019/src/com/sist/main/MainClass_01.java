package com.sist.main;
/*
 * 		7장 정리
 * 		------------JSP, Spring, Spring-Boot => 기본 자바
 * 					=> HTML/CSS/JavaScript
 * 					=> 데이터 저장 => 오라클 / MySQL(이 기술을 원하는 회사가 많음)
 * 					------------------------------------------------------ 데이터 분석(파이썬)
 * 
 * 	  	*** 인터페이스는 같은 기능을 가지는 클래스를 만들어서 제어
 * 					  ------- 강제화
 * 			interface I
 * 			{
 * 				void aaa();
 * 				void bbb();
 * 				void ccc();
 * 				//void default ddd(){}
 * 				//void default eee(){}
 * 				//void default kkk(){}
 * 				
 * 			}	
 *			class A implements I
 *			{	
 *				void aaa(){}
 * 				void bbb(){}
 * 				void ccc(){}
 * 				//void ddd(){}
 *			}
 *			class B implements I
 *			{	
 *				void aaa(){}
 * 				void bbb(){}
 * 				void ccc(){}
 * 				//void eee(){}	
 			}
 			class C implements I
 			{
 				void aaa(){}
 * 				void bbb(){}
 * 				void ccc(){}
 * 				//void kkk(){}
 			}
 			인터페이스로 관리할 수 없다 ==> 
 			I i=new A(); ==> i를 가지고 A가 가지고 있는 메소드를 제어
 				=> 접근 할 수 없는 메소드
 				접근 가능 : aaa(), bbb(), ccc()/ 접근 불가능: ddd()
 				----------------------------------------
 				A a=new A()
 			I i=new B(); ==> i를 가지고 B가 가지고 있는 메소드를 제어
 			I i=new C(); ==> i를 가지고 C가 가지고 있는 메소드를 제어
 			==> A,B,C가 유형이 같은 경우 한개의 이름으로 제어
 			  목적 => 서로 다른 클래스를 묶어서 관리
 			  		-------------- 관련
 			  		=> 관리 (소스코딩이 간결)
 			  		=> 인터페이스의 메소드 동일
 			  		예)
 			  				DriverManager
 			  					|
 			  		---------------------------------
 			  		|      |     |     |    |       |
 			  	   오라클  MySQL MSSQL DB2 SQLITE 사이베이스... => 인터페이스로 되어있음 각자를 알지않아도 DriverManager만 알면 사용가능
 			    VARCHAR2  VARCHAR
 			    CLOB        TEXT
 			    NUMBER		INT/DOUBLE
 			 => SQL => ANSI (표준화)
 			 
 			 	컬렉션
 			 	Collection
 			 		|
 			 --------------------------------
 			 |
 			 List
 			 |		
 		---------------------------------------
 		|			 	|		|		|		|   
 		ArrayList	Vector LinkedList Stack	Queue
 * 		1) 인터페이스 VS 추상클래스
 * 		   --------------------------------------------------------------------------------------------
 * 												인터페이스							추상클래스
 * 			--------------------------------------------------------------------------------------------
 * 			구현메소드를 가지고 있느냐?			선언된 메소드							선언된 메소드, 구현된 메소드
 * 											public void display();
 * 											1.8버전부터 바뀜) 구현된 메소드 사용가능
 * 											= default
 * 											  (접근지정어가 아님)
 * 											  그냥 default 라는 이름을 가진것
 * 											  public default void display2();
 * 											= static
 * 											  => 접근시에 반드시 인터페이스명으로만 접근가능
 * 			---------------------------------------------------------------------------------------------
 * 			인스턴스 변수						사용 불가능							사용 가능
 * 											=> 공용							private 변수 가능
 * 											=> 상수형 변수만 사용가능
 * 											=> public만 사용가능
 * 											=> openjdk
 * 												jdk => 1.9(private가 가능)
 * 												 	=> C/C++ 따라가고있음 => exe
 * 													=> 오라클에서 필요한 것 (윈도우)		
 * 			---------------------------------------------------------------------------------------------
 * 			생성자							생성자가 없다							생성자가 있다
 * 			---------------------------------------------------------------------------------------------
 * 			접근 범위							모든 내용을 공개						한정한다 (모든 접근지정어 사용)
 * 											=> 메소드, 변수
 * 			----------------------------------------------------------------------------------------------
 * 			상속								다중 상속								단일 상속
 * 											implements							extends
 * 											interface => interface
 * 													extends
 * 											interface => class
 * 													implements
 * 											=> 사용자정의, 라이브러리
 * 												=> 단일 상속이 중심이다
 * 											=> 윈도우 : 여러개 받는 경우가 있다
 * 			------------------------------------------------------------------------------------------------
 * 			** 공통점 : new를 이용해서 메모리 할당이 불가능하다
 * 					   => 상속을 내려서 상속받은 클래스가 구현해서 사용
 * 			** 목적 : 서로 다른 클래스를 연결해서 사용이 가능
 * 					 관련된 클래스를 모아서 사용할 때 주로 사용
 * 			** 실생활
 * 				=> 110V => 220V 바꿔주는 어댑터 : 인터페이스
 * 				=> 컴퓨터 : 마우스, 키보드
 * 					업체가 여러개
 * 					-----------
 * 					MS => 인터페이스 방출
 * 			--------------------------------------------------------------------------------------------------
 * 			인터페이스의 구성요소
 * 			public interface interface명
 * 			{
 * 				-----------------------------
 * 				상수 : 반드시 초기값 설정 (명시적으로 설정)
 * 				=> 개발자가 알아서 구현
 * 
 * 				(public static void final) int a=10;
 * 					=> 생략이 되면 접근지정어 / 제어어를 추가
 * 				----------------------------------
 * 				구현이 안된 메소드 : 프로그램에 맞게 구현
 * 					=> 개발자가 알아서 구현
 * 				(public abstract) void display();
 * 				--------------------------------
 * 				구현이 된 메소드   
 * 				=> 공통으로 사용되는 부분
 * 					=> 필요시마다 변경해서 사용
 * 				(public) default void mathod(){}
 * 						-------- 접근지저어가 아니라 구현된 메소드
 * 				(public) static void method(){}
 * 					==> 인터페이스명.메소드명()
 * 						------------------
 * 				--------------------------------
 * 			}
 * 				*** 만약에 기능 추가가 있는 경우에는 default를 이용한다
 * 					
 */

//static
interface I
{
	//private int a=10; ==> public만 사용가능
	//public 생략하면 => 컴파일러에 의해 자동으로 public 추가됨
	public static void display()
	{
		System.out.println("I:display() Call...");
	}
}
class A
{
	public static void aaa()
	{
		System.out.println("A:aaa() Call...");
	}
}
class B extends A
//        상속
{
	public void bbb()
	{
		aaa();
		A.aaa();
	}
}
class C implements I
//		 구현(상속) ==> class (단일 상속), interface(다중상속)
{
	public void ccc()
	{
		//display();   	 ==> (오류)
		I.display();  // ==> 인터페이스의 static 메소드는 인터페이스명으로만 접근가능
	}
}
public class MainClass_01 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
