package com.sist.main;
/*
 * 		1. 객체 지향 프로그램 => Application, Web Application
 * 							------------- ----------------
 * 												캡슐화, 인터페이스
 * 											 => 연산자,제어문, 메소드
 * 											 => 데이터베이스 연동
 * 												---------------
 * 				= 코드의 재사용이 높다 (기존의 코드를 변경, 추가)
 * 				= 코드 관리가 용이하다 (구조적 프로그램 => 메소드로 기능을 구분)
 * 				= 이미 사용중인 프로그램을 이용하기 때문에 신뢰성이 높다
 * 				= 대규모 프로젝트에 주로 사용
 * 				  -----------
 * 					Model 1 (JSP) => 홈페이지, 소규모 회사
 * 					--------- 통으로 프로그램 구현 (개인)
 * 					Model 2 => 공기업, 금융권			
 * 					--------- Front, Back, DataBase ==> MVC
 * 					Spring(MVC) => Front (MVC=> Vuex, Redux)
 * 														|
 * 													React-Query
 * 				=> 한 개의 서버에서 작업 => 서버 점검 시에 서비스 중단
 * 				   ----------------
 * 					그래서 여러개의 서버로 나눠서 작업 (MSA)
 * 					=> Spring Cloud
 * 					=> 데이터 분석 => 지능형웹 (단어를 주면 유사관련된걸 싹 다 가져오는것)
 * 					   추천
 * 					new Vue({
 * 					})
 * 					import 
 * 					class App extends React
 * 					{
 * 					}	
 * 					function App(){} => CDN
 * 
 * 		= 클래스의 구성
 * 		  ---- 
 * 			   공통적인 데이터,기능을 모아서 저장 후에 사용 => 추상화(사물을 단순화하는 작업)
 * 			   -----------  ---	
 * 				멤버변수		메소드
 * 				  |
 * 				 사람 : 이름, 나이, 키, 성별...
 * 					   컴퓨터, 기계, 자동차 // 이런 부분은 제외해야함, 누구나 다 공감하는 데이터만을 모아야함
 * 				
 * 				사물을 단순화 => 추상화 => 구체화
 * 				=> 한개의 클래스로 동작하는 것이 아니다
 * 				   여러개 클래스를 연관관계
 * 				   행위자 <===> 처리
 * 				    사람		  자판기
 * 				사용자, 관리자	<==> 웹 
 * 				---------------------
 * 				항상 행위자가 있어야 객체지향이 실행된다
 * 					(Actor)
 * 				-----------------------------------------------
 * 					--- 개발자마다 생각하는 데이터가 다르다
 * 					--- 맛집에 들어가는 데이터 추출해라
 * 					1) 설계에 필요한 데이터 설계 (벤치마킹) => 멤버변수
 * 					2) 기능 (메뉴, 버튼) => 메소드 => 멤버변수
 * 					3) 변수의 초기값을 어떻게 줄건지 => 생성자
 * 				------------------------------------------------
 * 				클래스를 메모리에 저장
 * 				 클래스명 변수명=new 클래스명()
 * 							      --------- 모든 클래스는 생성자를 가지고 있다
 * 
 * 				-------------------------------
 * 				재사용 / 데이터 변질,손실 / 변경이 쉽게... (객체지향) => 유지보수
 * 				----    ------------  ----------
 * 			상속, 포함		캡슐화 		다형성(오버라이딩,오버로딩)
 * 
 * 			*** 멤버변수
 * 				------
 * 				따로 사용할거냐 => 인스턴스 변수
 * 				한개만 사용할거냐 => 정적 변수
 * 				----------------------------- 데이터베이스 (정규화) 
 * 					=> 값 => 취미
 * 							 영화, 낚시, 쇼핑 => JOIN
 * 			
 * 			---------------------------------------------------------------
 * 			클래스의 구성 요소 => 5장
 * 			class A
 * 			{
 * 				------------------------
 * 					데이터 선언 ==> 데이터의 손실,변질 방지 => 은닉화
 * 								  private
 * 					 멤버변수 : new 이용할 때마다 따로 저장되는 공간을 만들어서 사용
 * 					 정적변수 : 한 개만 생성 => 공유할 때 사용 (앞에 static이 붙어있음)
 * 					=> private 데이터형 변수명;
 * 					   => 읽기/쓰기
 * 					   => 은닉화 VS 캡슐화의 차이점은?
 * 					   => 정적 변수 VS 인스턴스 변수의 사용처(언제 정적쓰고 언제 인스턴스 쓰는지?)
 * 				------------------------
 * 					데이터 초기화
 * 					 생성자
 * 						1) 특징
 * 							= 클래스명과 동일해야한다
 * 							= 리턴형이 없다
 * 							= 여러개 사용 가능 (오버로딩 기법)
 * 								** 오버로딩 : 기능추가 할 때 사용
 * 									메소드명 동일
 * 									매개변수의 갯수나 데이터형이 다르다
 * 									리턴형은 관계 없다
 * 									** 생성자는 필요시에만 사용
 * 										=> 생성자가 없는 경우에는 자동으로 디폴트 생성자 생성된 것
 * 																	----------
 * 																	매개변수가 없는 생성자
 * 						2) 역할
 * 							= 멤버변수에 초기화
 * 							= 메모리에 저장 시에 호출되는 메소드
 * 					 초기화 블록 : 컴팡일러에 의해 자동으로 호출
 * 							= 인스턴스 블록 
 * 								{		
 * 									((멤버변수, 정적변수)=>초기화 가능), 멤버메소드, 정적메소드 사용가능
 * 									  ------ 생성자 => 생성자를 반드시 호출
 * 								}
 * 							= 정적 블록 ==> MyBatis
 * 								{
 * 										정적변수(static)만 초기화가 가능
 * 										------- 정적변수는 자동초기화
 * 				------------------------
 * 					데이터 활용 
 * 					 메소드 ==> 다른 클래스와 통신(연결,연동할 때 사용) => 그래서 대부분 public 사용 
 * 					 -----
 * 					1) 종류 
 * 						= 일반멤버메소드 **가장많음
 * 							[접근지정어] 리턴형 메소드(매개변수목록)
 * 							{
 * 								기능
 * 							}
 * 						= 정적메소드 => 암호화/복호화
 * 							[접근지정어] static 리턴형 메소드(매개변수)
 * 							{
 * 								==> 멤버변수를 활용하지 않는 경우 (공통으로 적용하는 기능)
 * 							}
 * 							==> 윈도우 코딩한다하면 : 모든 클래스에서 적용 => 이미지 크기 조절
 * 							==> 웹 : 한글변환코드 ==> ISO-8859_1(ASC) ==> UTF-8
 * 						= 종단메소드 : 오버라이딩이 안되는 메소드 ==> 사용빈도가 거의 없다
 * 							[접근지정어] final 리턴형 메소드명(매개변수)
 * 							{
 * 								
 * 							}
 * 						= 추상메소드 : 구현이 안된 메소드 => 선언만 하는 메소드
 * 									 설계용
 * 									 => 추상 클래스 / 인터페이스
 * 									 => 여러개의 클래스를 한개의 이름으로 묶어서 처리
 * 										-----------------------------------
 * 										데이터 여러개 => 한개의 이름으로 제어
 * 													  배열
 * 										여러개의 클래스 => 인터페이스
 * 														결합성을 낮게 만들어준다
 * 														-----
 * 														클래스를 수정 => 다른 클래스에 영향
 * 														(하나가 에러났을 때 다른 클래스도 에러난다 => 결합성이 높다)
 * 														이걸 방지해주는게 인터페이스
 * 				------------------------
 * 			}
 * 			
 * 			객체지향 3대 특성 => 6장
 * 	
 * 				캡슐화 : private 변수 => 읽기/쓰기 메소드
 * 				상속 : 기존의 기능을 사용
 * 					  extends : 확장
 * 						=> 예외 : static, 생성자, 초기화블록, private은 접근이 안된다
 * 						=> final 클래스는 상속할 수 없다
 * 				다형성 : 변경 / 추가
 * 					   => 오버라이딩 / 오버로딩
 * 				------------------------------------
 * 				재사용 : 변경 (상속), 있는 그대로 (포함)
 * 											------ 멤버변수로 사용
 * 												   ------
 * 													기본형, 배열, 클래스, 열거형, 인터페이스
 * 																			 --------
 * 																			데이터베이스 연결
 * 							Connection
 * 								|
 * 						-----------------
 * 						|		|		|
 * 					Oracle	  MySQL		MSSQL
 * 			
 * 
 * 			클래스의 종류 => 7장
 * 				---------------------------------------
 * 				= 추상클래스
 * 				public abstract class ClassName
 * 				{
 * 				}
 * 				= 인터페이스 => 추상 클래스의 일종
 * 				public interface interface명
 * 				{
 * 					// 상수형 변수
 * 					// 선언만 된 메소드 ==> 윈도우 : 버튼, 마우스, 키보드 (인터페이스로 구현된것들)
 * 				}
 * 				---------------------------------------- 미완성된 클래스
 * 														------------- new를 이용해서 메모리 할당이 안된다
 * 																      상속 내려서 구현된 다음 사용
 * 				
 * 				= 내부 클래스 : 쓰레드, 네트워크, 데이터분석
 * 					= 멤버클래스
 * 						class A => 서버 => 접속 시 처리 윈도우
 * 						{ 
 * 							데이터 => 접속자 IP
 * 							class B => 통신서버 => 접속인하고 통신 쓰레드
 * 							{
 * 								데이터	
 * 							}
 * 						}
 * 					= 익명의 클래스
 * 					class A
 * 					{
 * 						B b=new B()
 * 						{
 * 							void display()
 * 							{
 * 							} // 오버라이딩
 * 						}
 * 					}
 * 					class B
 * 					{
 * 						void display()
 * 						{
 * 						}
 * 					}
 * 				
 * 			사전에 에러 방지 => 8장
 * 			1) 직접 처리
 * 				try ~ catch
 * 			2) 간접 처리
 * 				메소드() throws 예외처리
 * 			3) 임의 발생 => 테스트 할 때 사용
 * 			4) 사용자 정의 예외처리
 * 				
 * 			----------------- 여기까지 기본 문법
 * 			라이브러리 => 조립 => 9~15장
 * 				=> String, IO, Collection ==> SQL  => Network
 * 				   -----------------------
 * 					(얘네 중요하니까 무조건 외우기)
 * 
 */
import java.util.*;
import javax.swing.*;
import javax.swing.table.*;
import java.awt.*;
// 오버라이딩(재정의) => 기본(상속이 있어야 가능)
public class MainClass2 extends JFrame{
		
		//	포함 클래스
		// JTable : 목록 출력해주는것
		JTable table; // 모양
		DefaultTableModel model; // 테이블 데이터 제어
		//초기화
		public MainClass2()
		{
			String[] col= {"번호","이름","성별","주소","전화"};
			String[][] row=new String[0][5];
			model=new DefaultTableModel(row,col) 
			{

				@Override
				public boolean isCellEditable(int row, int column) {
					// TODO Auto-generated method stub
					return false;
				}
				
			};
			table=new JTable(model);
			JScrollPane js=new JScrollPane(table);
			//배치
			add("Center",js);
			String[] data= {"1","홍길동","남자","서울","010-1111-1111"};
			for(int i=0;i<10;i++)
			{
				model.addRow(data);
			}
			setSize(640,480);
			setVisible(true);
		}
		
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new MainClass2();
	}

}
